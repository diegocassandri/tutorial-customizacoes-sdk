# Fábrica de Software Senior - Aws Lambda Lib <!-- omit in toc -->

Biblioteca da Fábrica de Software Senior para padronização e auxílio na construção de constomizações utilizando lambdas no ambiente SDK G7 para interceptação de primitivas.

# Tabela de conteúdo <!-- omit in toc -->

- [Instalação](#instala%c3%a7%c3%a3o)
- [Principais módulos](#principais-m%c3%b3dulos)
- [Utilização](#utiliza%c3%a7%c3%a3o)
  - [Customizando o ambiente de execução do evento](#customizando-o-ambiente-de-execu%c3%a7%c3%a3o-do-evento)
  - [AsyncRuleValidator](#asyncrulevalidator)
    - [AsyncRuleValidator.validate()](#asyncrulevalidatorvalidate)
    - [AsyncRuleValidator.validateOneByOne()](#asyncrulevalidatorvalidateonebyone)
    - [Tratando o retorno das regras de validação](#tratando-o-retorno-das-regras-de-valida%c3%a7%c3%a3o)
  - [Padrão de retorno da função lambda](#padr%c3%a3o-de-retorno-da-fun%c3%a7%c3%a3o-lambda)
    - [Funções para construção da resposta](#fun%c3%a7%c3%b5es-para-constru%c3%a7%c3%a3o-da-resposta)
- [Testando as regras dentro do Cloud9](#testando-as-regras-dentro-do-cloud9)
- [Contribuindo com o projeto](#contribuindo-com-o-projeto)

## Instalação

A partir do root de um projeto **NodeJs**, instalar a dependência:

`npm install --save @seniorsistemas/fsw-aws-lambda`

Feito isso, os módulos já estarão disponíveis para utilização:

```js
require('@seniorsistemas/fsw-aws-lambda');
```

## Principais módulos

A biblioteca é distribuída como módulos no formato CommonJS por compatibilidade nativa com **Node v10.16.3** (versão atual suportada pela IDE [AWS Cloud9](https://aws.amazon.com/pt/cloud9/)). Os principais módulos são:

* `@seniorsistemas/fsw-aws-lambda`: Módulo principal, provê funções para manipular o evento nativo da Lambda AWS, configuração da resposta da lambda e gerencia a execução de regras;
* `@seniorsistemas/fsw-aws-lambda/utils`: Utilitários;
* `@seniorsistemas/fsw-aws-lambda/services`: Services com lógicas em comum entre projetos.

## Utilização

A utilização da biblioteca visa padronizar o tratamento de eventos recebidos e resposta retornada pela função Lambda e a execução de regras de execução. A documentação também pode ser consultada na respectiva documentação de código em cada função e classe.

Com a integração da biblioteca, o `index.js` da função lambda deve-se assimilar com o modelo abaixo:

**index.js**
```js
// Importação de funções e classe para execução de validações.
const {
    lambdaEvent,
    lambdaResponse,
    AsyncRuleValidator
} = require('@seniorsistemas/fsw-aws-lambda');

// Função principal da lambda, sempre deve ser 'async' ou retornar 
// uma Promise com o payload de resposta.
exports.handler = async event => {

    // Retorna o payload da requisição original do evento.
    // Sempre será um objeto JSON.
    const body = lambdaEvent.parseBody(event);

    // Lê e extrai informações do evento original da função lambda e
    // define as configurações de ambiente, como o ambiente de execução
    // (development, homologx, production) e variáveis de ambiente, como
    // a URL da plataforma e o token para autenticação.
    const eventInfo = lambdaEvent.createEventInfo(event);

    // Criação do executor das regras de validação, recebe como parâmetro
    // as informações extraídas do evento.
    return new AsyncRuleValidator(body, eventInfo)
        .validate([ // Adiciona as regras de validação a serem executadas.
            'rf01',
            'rf02',
            /* outras regras */
        ])

        // Após todas as regras serem executadas, avalia se há erros de
        // validação e retorna a resposta correspondente, sendo elas:
        // Erro de cliente (código 400) caso houveram erros de validação,
        // sucesso (código 200) caso contrário.
        .then(validationResult => {
            if (validationResult.hasErrors()) {
                return lambdaResponse
                .validationError(validationResult.getErrorsAsString());
            }

            return lambdaResponse.success(body);
        })

        // Em caso de alguma exceção ou erro inesperado, retorna erro
        // interno (código 417).
        .catch(lambdaResponse.internalError);
};
```

### Customizando o ambiente de execução do evento

Ao executar o código:
```js
const eventInfo = lambdaEvent.createEventInfo(event);
```
Já temos em mãos as variáveis de ambiente necessária para a execução das regras de validação. Entretanto, pode ser necessária a adição de mais variáveis ou a definição de valores padrão para as mesmas.

Os valores padrão podem ser informados como segundo parâmetro da função `createEventInfo`, tendo como definição:

```ts
interface EnvironmentData {
    basePlatformUrl: string;
    bearerToken: string;
}
```

Por exemplo:
```js
const eventInfo = lambdaEvent.createEventInfo(event, {
    basePlatformUrl: 'https://platform.senior.com.br/t/senior.com.br/bridge/1.0/rest',
    bearerToken: 'Bearer 15c2a9eca2e0f8faac36de609c7d05ca'
});
```

Caso não forem informados os valores padrão de variáveis de ambiente, serão utilizados os declarados nas constantes [environments.js](/lib/core/environments.js) conforme o ambiente identificado a partir dos dados do evento, no atributo `event.environment`.

> #ARQPDT-1923: O usuário liberado pelo SDK (ainda) não possui acesso às configurações de variáveis de ambiente, conforme [documentação oficial da AWS](https://docs.aws.amazon.com/lambda/latest/dg/env_variables.html). Portanto, faz-se necessário outro meio para definir as variáveis de ambiente.

### AsyncRuleValidator

Como o próprio nome sugere, é um validador de regras assíncrono (tudo é ou vira uma `Promise`).

As regras de validação são apenas funções, não precisam, necessariamente, serem módulos externos, apenas precisam obedecer à seguinte interface:

```js
function (body, event) {
    return 'Mensagem de erro';
}
// Ou
function (body, event) {
    return ['Uma mensagem de erro', 'Outra mensagem de erro'];
}
// Ou
async function (body, event) {
    return 'Mensagem de erro';
}
```

Onde o parâmetro `body` é o payload da requisição convertido no formato
objeto JSON e `event` é o objeto contendo os dados de evento original da função lambda. Cada regra de validação pode ser síncrona ou assíncrona, entretanto,
**a execução sempre será assíncrona** e podem retornar um, nenhum, ou uma lista de erros de validação.

Possui dois métodos principais para validação:
- [AsyncRuleValidator.validate()](#asyncrulevalidatorvalidate)
- [AsyncRuleValidator.validateOneByOne](#asyncrulevalidatorvalidateonebyone)

Ambos os métodos aceitam dois formatos de parâmetros:

1. **O nome da regra**. Nesse caso, a regra será carregada de um arquivo no diretório fixo `src/rules` a partir do root do projeto. Por exeplo: *'rf01'* será requerido do arquivo *'/src/rules/rf01.js'*. O arquivo da regra deve obedecer arquitetura de módulos, exportando a função para validação: `module.exports = async (body, event) => {}`.

2. **A função para execução das regras**, podendo conter nenhum, um ou dois parâmetros e retornar uma mensagem, uma lista de mensagens ou uma *Promise*.

#### AsyncRuleValidator.validate()

Executa uma série de regras de validação de forma assíncrona, onde **todas as regras serão executadas ao mesmo tempo** e o resultado será apresentado apenas quando todas as regras **terminarem sua execução**.

Exemplo:
```js
asyncRuleValidator
    .validate([
        'rf01',
        function (body) {  return 'Mensagem de erro'  },
        async (body, event) => ['Mensagem de erro'] ,
        () => 'Mensagem de erro'
    ]).then(/* ... */);
```

#### AsyncRuleValidator.validateOneByOne()

Executa uma série de regras de validação, executando uma regra por vez. Cada regra de validação pode ser **síncrona ou assíncrona**, entretanto, **a execução sempre terá comportamento síncrono** (a execução de uma regra trava a execução das seguintes). A primeira regra que retornar uma mensagem de validação excerrará a execução da cadeia de regras.

Exemplo:
```js
asyncRuleValidator
    .validateOneByOne([
        'rf01',
        function (body) {  return 'Mensagem de erro'  },
        async (body, event) => ['Mensagem de erro'] ,
        () => 'Mensagem de erro'
    ]).then(/* ... */);
```

#### Tratando o retorno das regras de validação

Após a execução bem sucedida das regras de validação, será invocado o método `.then()` da *Promise* retornada pelos métodos de validação. Este método receberá como argumento uma instância da classe `ValidationResult` a qual tem a responsabilidade de armazenar todas as mensagens retornadas por regras de validação e possui métodos auxiliares para posterior tratamento das mensagens.

Principais métodos da classe `ValidationResult`:
- `.hasErros()`: avalia se houveram erros de validação;
- `.getErrors()`: retorna um objeto contendo todas as mensagens de erro de validação, se houver.
- `.getErrorsAsString()` retorna uma string concatenando todas as mensagens de erro de validação separadas pelo caractere quebra de linha `\n`.

Caso alguma regra falhar na execução e lençar uma exceção, será invocado o método `.catch()` da *Promise* contendo informações sobre qual regra falhou e o detalhe da exceção.

### Padrão de retorno da função lambda

Os retornos da função lambda customizada são criados pelas funções do módulo `lambda-response`, tanto para sucesso, falha em regras de validação e erros inesperados.

O padrão de retorno sempre será:
```json
{
    statusCode: 200 | 400 | 417
    headers: {
        'Content-Type': 'application/json' | 'text/plain',
        'X-Senior-FSW': 'Customizacao'
    },
    body: {} | ''
}
```
> **Importante:** Em todos os cenários, o header `X-Senior-FSW` é retornado na resposta com o valor `Customizacao`, identificando que esse retorno foi interceptado e, possivelmente, modificado pela equipe de Customização da Fábrica de Software Senior.

Os códigos padrão de status HTTP retornados são:
* `200`: Sucesso;
* `400`: Erro de validação retornado por regras;
* `417`: Erro interno, durante a execução de regras ou outro erro inesperado.

O `Content-Type` pode variar dependendo do parâmetro informado para o `body`, caso o *body* seja um objeto JSON, o *Content-Type* será `application/json`, caso o *body* seja um texto, o *Content-Type* será *text/plain*. Quando uma resposta for gerada por exceções ou erros inesperados, o corpo da resposta sempre terá o prefixo `[FSW-ERROR]`.

#### Funções para construção da resposta

As funções disponíveis para criação do payload de resposta da função lambda são os seguintes:
```js
const { lambdaResponse } = require('@seniorsistemas/fsw-aws-lambda');

const body = {}; // Também pode ser string.

lambdaResponse.success(body);

lambdaResponse.validationError(body);

lambdaResponse.internalError(body);

const httpStatus = 404;
lambdaResponse.response(httpStatus, body);
```

## Testando as regras dentro do Cloud9

Após criada, a função lambda pode ser executada e depurada diretamente da IDE AWS Cloud9. Para isso, é necessário abrir o menu de execução da lambda:

1. No menu lateral direito, clicar na aba "AWS Resources" para listar as lambdas criadas.
   Escolha a lambda desejada para execução e clique com o botão direito, selecione a opção "Run" e, então, "Run Local".
   ![Menu de execução AWS Resources, indicando onde acessar o submenu "Run Local"](/.docs/images/menu_de_execucao_aws_resource.png "Menu de execução AWS Resources")

2. A aba que será aberta, é a aba de configuração de execução da função lambda. Para executar a função basta clicar no botão "Run" e para executar em modo debug, basta ativar o botão "Run in debug mode" e, então, clicar no botão "Run".
   Note que no payload há um atributo `"environment": "development"`, este atributo é customizado e não existirá em eventos reais quando a lambda for invocada, ele é utilizado para indicar à biblioteca configurar o ambiente de execução com as variáveis de desenvolvimento.
   Todo o conteúdo do campo payload **será o valor da variável `event` na execução da lambda**.
   ![Executar função lambda com payload customizado](/.docs/images/executar_local_e_debug.png "Executar função lambda com payload customizado")

3. Durante a execução em modo de depuração, no topo da janela de execução é possível controlar os passos de avanço da depuração, acompanhar valor de variáveis e a stack de execução. Clicando na aba "Immediate" na parte inferior da janela, será aberto um console para depuração onde é possível executar um código dentro do contexto do breakpoint.
   ![Controle de breakpoint e console de depuração](/.docs/images/breakpoint_e_console_debug.png "Controle de breakpoint e console de depuração")

## Contribuindo com o projeto

Para ver como pode contribuir com o projeto, leia as [instruções de contribuição](/CONTRIBUTING.md).
